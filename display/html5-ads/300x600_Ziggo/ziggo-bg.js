grid8player.components['ziggo-bg']={manifest: {  "id": "ziggo-bg",  "properties": [    {      "name": "color1",      "type": "color",      "value": "#FAA027"    },    {       "name": "color2",      "type": "color",      "value": "#F47922"    },    {      "name": "zoom",      "type": "number",      "value": "1"    },    {      "name": "speed",      "type": "number",      "value": "1"    }  ],  "fonts": [],  "libs":["ThreeJS"],  "width": 300,  "height": 600},styles: `      #$id{            height: 100%;          width: 100%;          background-color: $color2;      },    #headerCanvas { position: absolute;}  `,html: ``,init(element, pos, size, props) {let self=this;self.dom = element;self.width = size.initW;self.height = size.initH;self.render = null;self.canvas = null;self.vars = props.reduce((b,a)=>({...b,[a.name]:a.type=="number"?Number(a.value):a.value}),{});self.cam = new THREE.PerspectiveCamera(Math.pow(self.height/self.width,self.height/self.width<1?0.8:0.5)*15/Math.max(0.1,self.vars.zoom), self.width/self.height, 1, 1000);self.scene = new THREE.Scene();self.dom.isvisible = falseself.tickStop = falsethis.dom.show8 = function () {  self.render = new THREE.WebGLRenderer({antialias:false});  self.render.setPixelRatio(window.devicePixelRatio);  self.render.setSize(self.width,self.height);  self.canvas = self.render.domElement;  self.canvas.id = "headerCanvas";  self.dom.appendChild(self.canvas);  self.dom.isvisible = true  if(self.tickStop) upd8(null) }this.dom.hide8 = function () { if(self.render){  self.render.dispose()  self.render.forceContextLoss()}  while (self.dom.firstChild) {  self.dom.removeChild(element.firstChild); } self.dom.isvisible = false}self.cam.aspect = self.width/self.height;self.cam.position.x = 700self.cam.rotation.y = Math.PI/2const arr = [[[0,-129,74.88,-115.2,174.7,-82.92,199.7,-134.5,239,-129],[0,24.38,99.84,33.44,124.8,33.28,149.8,28.37,174.7,9.643,199.7,13.03,239,24.38],[0,116.3,74.88,109.9,149.8,119.8,174.7,142.4,199.7,128.6,239,116.3],[0,38.86,124.8,151.8,174.7,239.1,199.7,360.3,239,398.9],[0,56.43,74.88,63.63,112,60.32,149.8,44.1,174.7,21.83,199.7,41.97,215,51.3,239,56.43],[0,-107.1,49.92,-92.92,149.8,-49.19,174.7,-62.58,199.7,-112.5,239,-107.1]],[[0,73.89,74.88,96.54,174.7,163.9,199.7,67.75,239,73.89],[0,-6.688,99.84,-32.53,124.8,-32.38,149.8,-19.15,174.7,32.81,199.7,25.01,219,0,239,-6.688],[0,127.9,74.88,127.2,124.8,121.6,149.8,114.5,174.7,103.3,199.7,123.6,239,127.9],[0,65.41,74.88,67.11,124.8,75.09,149.8,84.59,174.7,103.3,199.7,74.69,239,65.41],[0,-54.18,150,-34.95,174.7,-39.52,199.7,-62.13,239,-54.18],[0,-58.09,149.8,32.75,174.7,84.11,199.7,257.8,239,301.9]],[[0,18,49.92,10.2,74.88,-12.15,99.84,6.477,124.8,21.77,149.8,27.36,199.7,27.94,239,18],[0,-174,49.92,-168.2,99.84,-102,124.8,-69.45,190,-170,239,-174],[0,74.3,49.92,83.25,74.88,80.42,99.84,66.68,124.8,72.18,199.7,76.06,239,74.3],[0,82,49.92,134.7,99.84,327,239,442],[0,-46.66,49.92,-43.4,74.88,-8.859,99.84,-11.97,149.8,-34.6,239,-46.66],[0,-90.04,49.92,-110.9,74.88,-111.6,99.84,-76.99,124.8,-71.35,239,-90.04]]]var things = [{a:45,"e":2},{a:180,e:1.5},{a:225,e:1.5}]const dims = ["x","y","z"], grp =  new THREE.Group(); grp.quaternion.set(0.12147763989913307,-0.07951479641440938,-0.009763189363027109,0.9893559825912882)grp.position.set(233.567, 41.635, -99.412);self.scene.add( grp );self.scene.background = new THREE.Color(self.vars.color2);function shade(cl,a,e){const clr = new THREE.Color(self.vars.color1);var vts =  "varying vec2 vUv;\nvoid main() {\n\tvUv = uv;\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}"  var fms =  "varying vec2 vUv;\nuniform float angl;\nuniform float expo;\n\nvoid main() {\n\tfloat dist = length(max(abs(vUv - vec2(0.5)) - vec2(0.36), 0.0)) - 0.13;\n\tfloat alph = 1.0 - smoothstep(0.0, 0.001, dist);\n\tfloat hor = sin(radians(angl));\n\tfloat ver = cos(radians(angl));\n\tgl_FragColor = vec4(" + clr.r + "," + clr.g + "," + clr.b + ",alph * pow(0.5+1.1*(hor*( vUv.x-0.5)+ver*(vUv.y-0.5))/(abs(hor)+abs(ver)),expo));\n}"return new THREE.ShaderMaterial({side: THREE.DoubleSide,depthTest:false,depthWrite:false,transparent:true,uniforms: { angl: { value: a},  expo: { value: e }},vertexShader: vts, fragmentShader:fms})} var reps = self.vars.speed>0?3/(self.vars.speed):0var tl = gsap.timeline({repeat:reps})tl.to(self.cam.rotation,{z:-Math.PI*2,duration:239/24,ease: "sine.inOut"})for (let h = 0; h < things.length; h++){const geo = new THREE.PlaneGeometry(100,100);const mat = shade(self.vars.color1,things[h].a,things[h].e)const thing = new THREE.Mesh( geo, mat ); grp.add(thing)  thing.rotation.order = "ZYX"for (let i = 0; i < 6; i++){const tmp = myCurve(arr[h][i],i), kfs = [];var old = 0for (let j = 0; j < tmp.length; j++){const kf = {"duration":(tmp[j].x-old)/24};kf[dims[i % 3]]= tmp[j].y*(i<3?1:Math.PI/180);kfs.push(kf)  old = tmp[j].x;}tl.to(thing[i<3?"position":"rotation"],{keyframes:kfs},0)     }} tl.timeScale(self.vars.speed); function myCurve(ar,i){const pnts = [];for (let i = 0; i < ar.length-1; i+=2){pnts.push(new THREE.Vector3(ar[i], ar[i+1],0 ))}const spline = i>2?new THREE.SplineCurve(pnts):new THREE.CatmullRomCurve3(pnts,false, "chordal");return spline.getSpacedPoints(125);}console.log("tl.duration()"+tl.duration())gsap.ticker.add(upd8)function upd8(event) {if(self.dom.isvisible) self.render.render(self.scene, self.cam);}gsap.delayedCall(30, function(){gsap.ticker.remove(upd8);self.tickStop=true});},animate(timeline) {},intersect(ratio){    if (ratio>0){      this.dom.show8()     }else{     this.dom.hide8()     } } ,// global eventsonMouseClick() {},onMouseOver() {},onMouseOut() {}}