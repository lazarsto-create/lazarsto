grid8player.effects['responsive-fontSize']={
styles: `    .maxLines{      height: auto!important;      display: -webkit-box;      -webkit-box-orient: vertical;      -webkit-line-clamp: var(--maxLines);      overflow:visible;    }       .inlineSaf>div{      display:inline-block!important;    }    `,  init(el, pos, size, props) {    function getLineBreaks(node) {  if(!node || !node.parentNode || node.nodeType !== 3)    return [];  const range = document.createRange();  range.setStart(node, 0);  let prevBottom = range.getBoundingClientRect().bottom;  let str = node.textContent;  let current = 1;  let lastFound = 0;  let bottom = 0;  while(current <= str.length) {    range.setStart(node, current);    if(current < str.length -1)     range.setEnd(node, current+1);    bottom = range.getBoundingClientRect().bottom;    if(bottom > prevBottom) {        var hyp = vars["word-break"]>2 && str.charAt(current-1) != " " && str.charAt(current-1).charCodeAt(0) != 10? "-":"";       for(let i = 0; i < current; i++) {          node.textContent =  str.substring(0, current-i) + hyp+' ' + str.substring(current-i);          range.setStart(node, current-i);          range.setEnd(node, current+1-i);          if(hyp == "" || prevBottom>= range.getBoundingClientRect().bottom){            current -= i;            break;          }        }      str = node.textContent      prevBottom = bottom;      lastFound = current;    }    current++;  }}    this.dom = el;    grid8player.el= el    el.saf = navigator.vendor.match(/apple/i) &&             !navigator.userAgent.match(/crios/i) &&             !navigator.userAgent.match(/fxios/i) &&             !navigator.userAgent.match(/Opera/);     const fontSiz = (el) => parseInt(window.getComputedStyle(el, null).getPropertyValue('font-size').slice(0,-2));    var vars = props,fSize=fontSiz(el),lineH = el.style.lineHeight,maskLines=false    if(vars.language>0)el.setAttribute("lang",["","en","nl","de","fr","es"][vars.language]);        if(el.splitText){      el.splitText.revert()      var mani = manifest.layers.filter(lay => lay.guid==el.id.slice(6))[0];        maskLines = (mani && mani.textAnimation)?mani.textAnimation.mask:false    }    lineH = lineH.slice(-2)=="px"?lineH.slice(0,-2)/fSize:0;    function wordBreak(){      if(vars["word-break"]==1) el.style.wordBreak = "break-all";      if(vars["word-break"]>1) el.style.wordBreak = "break-word";      el.style.hyphens = vars["word-break"]>2?"auto":"manual";    }    wordBreak();    var oldHeight = size.h;    var maxHeight = vars.maxHeight>0?vars.maxHeight:oldHeight;    function countLines(el,h){       if(lineH>0){        return h?fSize*lineH:Math.round(el.scrollHeight/(fSize*lineH))       }else{        var tmp = document.createElement(el.nodeName), a;        tmp.setAttribute("style", "position:absolute;margin:0;padding:0;"+"font-family:"+(el.style.fontFamily || "inherit") + "; " + "font-size:" +fSize+'px' );        el.parentNode.appendChild(tmp);        tmp.innerHTML = "A";        a = tmp.clientHeight;        tmp.parentNode.removeChild(tmp);        return h?a:Math.round(el.scrollHeight/a);       }    }           el.style.height = "auto"      function scaleFont(){         el.style.fontSize = fSize + 'px';         if(lineH>0) el.style.lineHeight=(fSize*lineH)+'px';       }      while ((vars.maxSize == 0 || fSize < vars.maxSize) && el.scrollHeight < maxHeight) {          fSize++;          scaleFont()      }            while (fSize > vars.minSize &&  (el.offsetHeight > maxHeight || ( vars.maxLines>0 && countLines(el) > vars.maxLines))) {         fSize -= (vars.precision>=0?vars.precision:1)         scaleFont()           }      const oldSize = fSize;      if(vars["word-fit"]>0){        el.style.wordBreak = "unset"        el.style.hyphens = "none"        while (el.scrollWidth> el.clientWidth) {           fSize -= (vars.precision>=0?vars.precision:1)           if(fSize<vars.minSize){            console.log("couldnt size down to "+fSize + "will revert to "+ oldSize)            fSize = oldSize            scaleFont()            wordBreak();            break;           }else{            scaleFont()          }        }      }      function alignV(){        const vAlign = vars["vertical-aligning"];      if (vAlign <=0) return;       const extra = oldHeight - el.clientHeight;       if(extra>0) el.style.paddingTop = (extra/(vAlign>1?1:2))+"px";       }      if(el.scrollHeight>maxHeight || (vars.maxLines>0 && countLines(el) > vars.maxLines)){        el.classList.add("maxLines")        if(el.saf) el.classList.add("inlineSaf")        el.style.setProperty('--maxLines',  Math.min(countLines(el) , vars.maxLines))        alignV()        if (vars.shrink<=0){          const extra = oldHeight - el.clientHeight;          if(extra>0) el.style.borderBottom = extra+"px solid #00000000";          }      }else{        el.classList.remove("maxLines")        if (vars.shrink<=0){          el.style.height = gsap.utils.clamp(oldHeight, maxHeight, el.scrollHeight)+"px";        }else{         alignV()         }      }    if(el.splitText){      getLineBreaks(el.childNodes[0])      el.splitText.split();                 for (let index = 0; index < el.splitText.lines.length; index++) {            const line = el.splitText.lines[index];            if(vars.maxLines>0 && index>vars.maxLines-1){             if (index>vars.maxLines){line.remove();}else{line.style.visibility = "hidden";}            }else if (maskLines) {              const lineClone = line.cloneNode(true);              lineClone.className = "";              lineClone.style.overflow = "hidden";              lineClone.style.height = line.offsetHeight * 1.1 + "px";              lineClone.innerHTML = "";              line.parentNode.appendChild(lineClone);              lineClone.appendChild(line);            }          }            }     el.dispatchEvent(new CustomEvent("resp", {}))     el.resp = true;  },  animate(timeline) {   if(this.dom.saf && timeline.isActive()) this.dom.classList.add('maxLines')  },  onStart(first){    var el = this.dom    if (el.saf){     window.setTimeout(function() {       el.classList.add('maxLines')}, 0);   }  }};